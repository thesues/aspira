// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: aspirapb.proto

package aspirapb

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type TnxType int32

const (
	TnxType_prepare TnxType = 0
	TnxType_commit  TnxType = 1
	TnxType_abort   TnxType = 3
	TnxType_retry   TnxType = 4
)

var TnxType_name = map[int32]string{
	0: "prepare",
	1: "commit",
	3: "abort",
	4: "retry",
}

var TnxType_value = map[string]int32{
	"prepare": 0,
	"commit":  1,
	"abort":   3,
	"retry":   4,
}

func (x TnxType) String() string {
	return proto.EnumName(TnxType_name, int32(x))
}

func (TnxType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{0}
}

type EntryMeta_Type int32

const (
	EntryMeta_Put           EntryMeta_Type = 0
	EntryMeta_LeaderCommit  EntryMeta_Type = 1
	EntryMeta_ConfChange    EntryMeta_Type = 2
	EntryMeta_PutWithOffset EntryMeta_Type = 3
)

var EntryMeta_Type_name = map[int32]string{
	0: "Put",
	1: "LeaderCommit",
	2: "ConfChange",
	3: "PutWithOffset",
}

var EntryMeta_Type_value = map[string]int32{
	"Put":           0,
	"LeaderCommit":  1,
	"ConfChange":    2,
	"PutWithOffset": 3,
}

func (x EntryMeta_Type) String() string {
	return proto.EnumName(EntryMeta_Type_name, int32(x))
}

func (EntryMeta_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{5, 0}
}

type AspiraProposal_Type int32

const (
	AspiraProposal_Put           AspiraProposal_Type = 0
	AspiraProposal_PutWithOffset AspiraProposal_Type = 1
	AspiraProposal_Delete        AspiraProposal_Type = 2
)

var AspiraProposal_Type_name = map[int32]string{
	0: "Put",
	1: "PutWithOffset",
	2: "Delete",
}

var AspiraProposal_Type_value = map[string]int32{
	"Put":           0,
	"PutWithOffset": 1,
	"Delete":        2,
}

func (x AspiraProposal_Type) String() string {
	return proto.EnumName(AspiraProposal_Type_name, int32(x))
}

func (AspiraProposal_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{6, 0}
}

type WorkerStatus_ProgressType int32

const (
	WorkerStatus_Probe     WorkerStatus_ProgressType = 0
	WorkerStatus_Replicate WorkerStatus_ProgressType = 1
	WorkerStatus_Snapshot  WorkerStatus_ProgressType = 2
	WorkerStatus_Unknown   WorkerStatus_ProgressType = 3
	WorkerStatus_Leader    WorkerStatus_ProgressType = 4
)

var WorkerStatus_ProgressType_name = map[int32]string{
	0: "Probe",
	1: "Replicate",
	2: "Snapshot",
	3: "Unknown",
	4: "Leader",
}

var WorkerStatus_ProgressType_value = map[string]int32{
	"Probe":     0,
	"Replicate": 1,
	"Snapshot":  2,
	"Unknown":   3,
	"Leader":    4,
}

func (x WorkerStatus_ProgressType) String() string {
	return proto.EnumName(WorkerStatus_ProgressType_name, int32(x))
}

func (WorkerStatus_ProgressType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{17, 0}
}

// Worker services.
type Payload struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=Data,proto3" json:"Data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Payload) Reset()         { *m = Payload{} }
func (m *Payload) String() string { return proto.CompactTextString(m) }
func (*Payload) ProtoMessage()    {}
func (*Payload) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{0}
}
func (m *Payload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Payload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Payload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Payload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Payload.Merge(m, src)
}
func (m *Payload) XXX_Size() int {
	return m.Size()
}
func (m *Payload) XXX_DiscardUnknown() {
	xxx_messageInfo_Payload.DiscardUnknown(m)
}

var xxx_messageInfo_Payload proto.InternalMessageInfo

func (m *Payload) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type RaftContext struct {
	Id                   uint64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Gid                  uint64   `protobuf:"varint,2,opt,name=gid,proto3" json:"gid,omitempty"`
	Addr                 string   `protobuf:"bytes,3,opt,name=addr,proto3" json:"addr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RaftContext) Reset()         { *m = RaftContext{} }
func (m *RaftContext) String() string { return proto.CompactTextString(m) }
func (*RaftContext) ProtoMessage()    {}
func (*RaftContext) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{1}
}
func (m *RaftContext) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftContext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftContext.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftContext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftContext.Merge(m, src)
}
func (m *RaftContext) XXX_Size() int {
	return m.Size()
}
func (m *RaftContext) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftContext.DiscardUnknown(m)
}

var xxx_messageInfo_RaftContext proto.InternalMessageInfo

func (m *RaftContext) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RaftContext) GetGid() uint64 {
	if m != nil {
		return m.Gid
	}
	return 0
}

func (m *RaftContext) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

//save MembershipState into
//workerID=>Addr
type MembershipState struct {
	Nodes                map[uint64]string `protobuf:"bytes,1,rep,name=nodes,proto3" json:"nodes,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *MembershipState) Reset()         { *m = MembershipState{} }
func (m *MembershipState) String() string { return proto.CompactTextString(m) }
func (*MembershipState) ProtoMessage()    {}
func (*MembershipState) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{2}
}
func (m *MembershipState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MembershipState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MembershipState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MembershipState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MembershipState.Merge(m, src)
}
func (m *MembershipState) XXX_Size() int {
	return m.Size()
}
func (m *MembershipState) XXX_DiscardUnknown() {
	xxx_messageInfo_MembershipState.DiscardUnknown(m)
}

var xxx_messageInfo_MembershipState proto.InternalMessageInfo

func (m *MembershipState) GetNodes() map[uint64]string {
	if m != nil {
		return m.Nodes
	}
	return nil
}

type Snapshot struct {
	Context *RaftContext `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	Index   uint64       `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	ReadTs  uint64       `protobuf:"varint,3,opt,name=read_ts,json=readTs,proto3" json:"read_ts,omitempty"`
	// done is used to indicate that snapshot stream was a success.
	Done bool `protobuf:"varint,4,opt,name=done,proto3" json:"done,omitempty"`
	// since_ts stores the ts of the last snapshot to support diff snap updates.
	SinceTs              uint64   `protobuf:"varint,5,opt,name=since_ts,json=sinceTs,proto3" json:"since_ts,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Snapshot) Reset()         { *m = Snapshot{} }
func (m *Snapshot) String() string { return proto.CompactTextString(m) }
func (*Snapshot) ProtoMessage()    {}
func (*Snapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{3}
}
func (m *Snapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Snapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Snapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Snapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Snapshot.Merge(m, src)
}
func (m *Snapshot) XXX_Size() int {
	return m.Size()
}
func (m *Snapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_Snapshot.DiscardUnknown(m)
}

var xxx_messageInfo_Snapshot proto.InternalMessageInfo

func (m *Snapshot) GetContext() *RaftContext {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *Snapshot) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *Snapshot) GetReadTs() uint64 {
	if m != nil {
		return m.ReadTs
	}
	return 0
}

func (m *Snapshot) GetDone() bool {
	if m != nil {
		return m.Done
	}
	return false
}

func (m *Snapshot) GetSinceTs() uint64 {
	if m != nil {
		return m.SinceTs
	}
	return 0
}

type RaftBatch struct {
	Context              *RaftContext `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	Payload              *Payload     `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *RaftBatch) Reset()         { *m = RaftBatch{} }
func (m *RaftBatch) String() string { return proto.CompactTextString(m) }
func (*RaftBatch) ProtoMessage()    {}
func (*RaftBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{4}
}
func (m *RaftBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftBatch.Merge(m, src)
}
func (m *RaftBatch) XXX_Size() int {
	return m.Size()
}
func (m *RaftBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftBatch.DiscardUnknown(m)
}

var xxx_messageInfo_RaftBatch proto.InternalMessageInfo

func (m *RaftBatch) GetContext() *RaftContext {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *RaftBatch) GetPayload() *Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

type EntryMeta struct {
	Term                 uint64         `protobuf:"varint,1,opt,name=Term,proto3" json:"Term,omitempty"`
	Index                uint64         `protobuf:"varint,2,opt,name=Index,proto3" json:"Index,omitempty"`
	EntryType            EntryMeta_Type `protobuf:"varint,3,opt,name=EntryType,proto3,enum=aspirapb.EntryMeta_Type" json:"EntryType,omitempty"`
	Data                 []byte         `protobuf:"bytes,4,opt,name=Data,proto3" json:"Data,omitempty"`
	AssociateKey         string         `protobuf:"bytes,5,opt,name=associateKey,proto3" json:"associateKey,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *EntryMeta) Reset()         { *m = EntryMeta{} }
func (m *EntryMeta) String() string { return proto.CompactTextString(m) }
func (*EntryMeta) ProtoMessage()    {}
func (*EntryMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{5}
}
func (m *EntryMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EntryMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EntryMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EntryMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EntryMeta.Merge(m, src)
}
func (m *EntryMeta) XXX_Size() int {
	return m.Size()
}
func (m *EntryMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_EntryMeta.DiscardUnknown(m)
}

var xxx_messageInfo_EntryMeta proto.InternalMessageInfo

func (m *EntryMeta) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *EntryMeta) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *EntryMeta) GetEntryType() EntryMeta_Type {
	if m != nil {
		return m.EntryType
	}
	return EntryMeta_Put
}

func (m *EntryMeta) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *EntryMeta) GetAssociateKey() string {
	if m != nil {
		return m.AssociateKey
	}
	return ""
}

type AspiraProposal struct {
	ProposalType         AspiraProposal_Type `protobuf:"varint,1,opt,name=ProposalType,proto3,enum=aspirapb.AspiraProposal_Type" json:"ProposalType,omitempty"`
	Key                  uint64              `protobuf:"varint,2,opt,name=key,proto3" json:"key,omitempty"`
	Offset               uint64              `protobuf:"varint,3,opt,name=offset,proto3" json:"offset,omitempty"`
	AssociateKey         string              `protobuf:"bytes,4,opt,name=associateKey,proto3" json:"associateKey,omitempty"`
	Data                 []byte              `protobuf:"bytes,5,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *AspiraProposal) Reset()         { *m = AspiraProposal{} }
func (m *AspiraProposal) String() string { return proto.CompactTextString(m) }
func (*AspiraProposal) ProtoMessage()    {}
func (*AspiraProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{6}
}
func (m *AspiraProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AspiraProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AspiraProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AspiraProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AspiraProposal.Merge(m, src)
}
func (m *AspiraProposal) XXX_Size() int {
	return m.Size()
}
func (m *AspiraProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_AspiraProposal.DiscardUnknown(m)
}

var xxx_messageInfo_AspiraProposal proto.InternalMessageInfo

func (m *AspiraProposal) GetProposalType() AspiraProposal_Type {
	if m != nil {
		return m.ProposalType
	}
	return AspiraProposal_Put
}

func (m *AspiraProposal) GetKey() uint64 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *AspiraProposal) GetOffset() uint64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *AspiraProposal) GetAssociateKey() string {
	if m != nil {
		return m.AssociateKey
	}
	return ""
}

func (m *AspiraProposal) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type BlobRaftMessageRequest struct {
	Context              *RaftContext `protobuf:"bytes,1,opt,name=context,proto3" json:"context,omitempty"`
	Payload              *Payload     `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *BlobRaftMessageRequest) Reset()         { *m = BlobRaftMessageRequest{} }
func (m *BlobRaftMessageRequest) String() string { return proto.CompactTextString(m) }
func (*BlobRaftMessageRequest) ProtoMessage()    {}
func (*BlobRaftMessageRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{7}
}
func (m *BlobRaftMessageRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlobRaftMessageRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlobRaftMessageRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlobRaftMessageRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlobRaftMessageRequest.Merge(m, src)
}
func (m *BlobRaftMessageRequest) XXX_Size() int {
	return m.Size()
}
func (m *BlobRaftMessageRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BlobRaftMessageRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BlobRaftMessageRequest proto.InternalMessageInfo

func (m *BlobRaftMessageRequest) GetContext() *RaftContext {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *BlobRaftMessageRequest) GetPayload() *Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

type BlobRaftMessageResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlobRaftMessageResponse) Reset()         { *m = BlobRaftMessageResponse{} }
func (m *BlobRaftMessageResponse) String() string { return proto.CompactTextString(m) }
func (*BlobRaftMessageResponse) ProtoMessage()    {}
func (*BlobRaftMessageResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{8}
}
func (m *BlobRaftMessageResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlobRaftMessageResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlobRaftMessageResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlobRaftMessageResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlobRaftMessageResponse.Merge(m, src)
}
func (m *BlobRaftMessageResponse) XXX_Size() int {
	return m.Size()
}
func (m *BlobRaftMessageResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BlobRaftMessageResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BlobRaftMessageResponse proto.InternalMessageInfo

type AddWorkerRequest struct {
	Gid                  uint64   `protobuf:"varint,1,opt,name=gid,proto3" json:"gid,omitempty"`
	Id                   uint64   `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	JoinCluster          string   `protobuf:"bytes,3,opt,name=joinCluster,proto3" json:"joinCluster,omitempty"`
	InitialCluster       string   `protobuf:"bytes,4,opt,name=initialCluster,proto3" json:"initialCluster,omitempty"`
	Type                 TnxType  `protobuf:"varint,5,opt,name=type,proto3,enum=aspirapb.TnxType" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddWorkerRequest) Reset()         { *m = AddWorkerRequest{} }
func (m *AddWorkerRequest) String() string { return proto.CompactTextString(m) }
func (*AddWorkerRequest) ProtoMessage()    {}
func (*AddWorkerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{9}
}
func (m *AddWorkerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddWorkerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddWorkerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddWorkerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddWorkerRequest.Merge(m, src)
}
func (m *AddWorkerRequest) XXX_Size() int {
	return m.Size()
}
func (m *AddWorkerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddWorkerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddWorkerRequest proto.InternalMessageInfo

func (m *AddWorkerRequest) GetGid() uint64 {
	if m != nil {
		return m.Gid
	}
	return 0
}

func (m *AddWorkerRequest) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *AddWorkerRequest) GetJoinCluster() string {
	if m != nil {
		return m.JoinCluster
	}
	return ""
}

func (m *AddWorkerRequest) GetInitialCluster() string {
	if m != nil {
		return m.InitialCluster
	}
	return ""
}

func (m *AddWorkerRequest) GetType() TnxType {
	if m != nil {
		return m.Type
	}
	return TnxType_prepare
}

type AddWorkerResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddWorkerResponse) Reset()         { *m = AddWorkerResponse{} }
func (m *AddWorkerResponse) String() string { return proto.CompactTextString(m) }
func (*AddWorkerResponse) ProtoMessage()    {}
func (*AddWorkerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{10}
}
func (m *AddWorkerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddWorkerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddWorkerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddWorkerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddWorkerResponse.Merge(m, src)
}
func (m *AddWorkerResponse) XXX_Size() int {
	return m.Size()
}
func (m *AddWorkerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AddWorkerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AddWorkerResponse proto.InternalMessageInfo

type PutStreamRequest struct {
	// Types that are valid to be assigned to Data:
	//	*PutStreamRequest_Gid
	//	*PutStreamRequest_Payload
	Data                 isPutStreamRequest_Data `protobuf_oneof:"data"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *PutStreamRequest) Reset()         { *m = PutStreamRequest{} }
func (m *PutStreamRequest) String() string { return proto.CompactTextString(m) }
func (*PutStreamRequest) ProtoMessage()    {}
func (*PutStreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{11}
}
func (m *PutStreamRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PutStreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PutStreamRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PutStreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PutStreamRequest.Merge(m, src)
}
func (m *PutStreamRequest) XXX_Size() int {
	return m.Size()
}
func (m *PutStreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PutStreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PutStreamRequest proto.InternalMessageInfo

type isPutStreamRequest_Data interface {
	isPutStreamRequest_Data()
	MarshalTo([]byte) (int, error)
	Size() int
}

type PutStreamRequest_Gid struct {
	Gid uint64 `protobuf:"varint,1,opt,name=gid,proto3,oneof" json:"gid,omitempty"`
}
type PutStreamRequest_Payload struct {
	Payload *Payload `protobuf:"bytes,2,opt,name=payload,proto3,oneof" json:"payload,omitempty"`
}

func (*PutStreamRequest_Gid) isPutStreamRequest_Data()     {}
func (*PutStreamRequest_Payload) isPutStreamRequest_Data() {}

func (m *PutStreamRequest) GetData() isPutStreamRequest_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *PutStreamRequest) GetGid() uint64 {
	if x, ok := m.GetData().(*PutStreamRequest_Gid); ok {
		return x.Gid
	}
	return 0
}

func (m *PutStreamRequest) GetPayload() *Payload {
	if x, ok := m.GetData().(*PutStreamRequest_Payload); ok {
		return x.Payload
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*PutStreamRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*PutStreamRequest_Gid)(nil),
		(*PutStreamRequest_Payload)(nil),
	}
}

type PutRequest struct {
	Gid                  uint64   `protobuf:"varint,1,opt,name=gid,proto3" json:"gid,omitempty"`
	Payload              *Payload `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PutRequest) Reset()         { *m = PutRequest{} }
func (m *PutRequest) String() string { return proto.CompactTextString(m) }
func (*PutRequest) ProtoMessage()    {}
func (*PutRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{12}
}
func (m *PutRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PutRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PutRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PutRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PutRequest.Merge(m, src)
}
func (m *PutRequest) XXX_Size() int {
	return m.Size()
}
func (m *PutRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PutRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PutRequest proto.InternalMessageInfo

func (m *PutRequest) GetGid() uint64 {
	if m != nil {
		return m.Gid
	}
	return 0
}

func (m *PutRequest) GetPayload() *Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

type PutResponse struct {
	Gid                  uint64   `protobuf:"varint,1,opt,name=gid,proto3" json:"gid,omitempty"`
	Oid                  uint64   `protobuf:"varint,2,opt,name=oid,proto3" json:"oid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PutResponse) Reset()         { *m = PutResponse{} }
func (m *PutResponse) String() string { return proto.CompactTextString(m) }
func (*PutResponse) ProtoMessage()    {}
func (*PutResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{13}
}
func (m *PutResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PutResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PutResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PutResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PutResponse.Merge(m, src)
}
func (m *PutResponse) XXX_Size() int {
	return m.Size()
}
func (m *PutResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PutResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PutResponse proto.InternalMessageInfo

func (m *PutResponse) GetGid() uint64 {
	if m != nil {
		return m.Gid
	}
	return 0
}

func (m *PutResponse) GetOid() uint64 {
	if m != nil {
		return m.Oid
	}
	return 0
}

type GetRequest struct {
	Gid                  uint64   `protobuf:"varint,1,opt,name=gid,proto3" json:"gid,omitempty"`
	Oid                  uint64   `protobuf:"varint,2,opt,name=oid,proto3" json:"oid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetRequest) Reset()         { *m = GetRequest{} }
func (m *GetRequest) String() string { return proto.CompactTextString(m) }
func (*GetRequest) ProtoMessage()    {}
func (*GetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{14}
}
func (m *GetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetRequest.Merge(m, src)
}
func (m *GetRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetRequest proto.InternalMessageInfo

func (m *GetRequest) GetGid() uint64 {
	if m != nil {
		return m.Gid
	}
	return 0
}

func (m *GetRequest) GetOid() uint64 {
	if m != nil {
		return m.Oid
	}
	return 0
}

//zero service
type ZeroAllocIDRequest struct {
	//header
	Count                int32    `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ZeroAllocIDRequest) Reset()         { *m = ZeroAllocIDRequest{} }
func (m *ZeroAllocIDRequest) String() string { return proto.CompactTextString(m) }
func (*ZeroAllocIDRequest) ProtoMessage()    {}
func (*ZeroAllocIDRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{15}
}
func (m *ZeroAllocIDRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZeroAllocIDRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZeroAllocIDRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZeroAllocIDRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZeroAllocIDRequest.Merge(m, src)
}
func (m *ZeroAllocIDRequest) XXX_Size() int {
	return m.Size()
}
func (m *ZeroAllocIDRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ZeroAllocIDRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ZeroAllocIDRequest proto.InternalMessageInfo

func (m *ZeroAllocIDRequest) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

//allocID range from [start,end), half open
type ZeroAllocIDResponse struct {
	Start                uint64   `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	End                  uint64   `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ZeroAllocIDResponse) Reset()         { *m = ZeroAllocIDResponse{} }
func (m *ZeroAllocIDResponse) String() string { return proto.CompactTextString(m) }
func (*ZeroAllocIDResponse) ProtoMessage()    {}
func (*ZeroAllocIDResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{16}
}
func (m *ZeroAllocIDResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZeroAllocIDResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZeroAllocIDResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZeroAllocIDResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZeroAllocIDResponse.Merge(m, src)
}
func (m *ZeroAllocIDResponse) XXX_Size() int {
	return m.Size()
}
func (m *ZeroAllocIDResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ZeroAllocIDResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ZeroAllocIDResponse proto.InternalMessageInfo

func (m *ZeroAllocIDResponse) GetStart() uint64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *ZeroAllocIDResponse) GetEnd() uint64 {
	if m != nil {
		return m.End
	}
	return 0
}

//I do not want to import raft's proto.
//the progress should be the same
type WorkerStatus struct {
	//workerid => progressType
	Progress    map[uint64]WorkerStatus_ProgressType `protobuf:"bytes,1,rep,name=progress,proto3" json:"progress,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3,enum=aspirapb.WorkerStatus_ProgressType"`
	RaftContext *RaftContext                         `protobuf:"bytes,2,opt,name=raftContext,proto3" json:"raftContext,omitempty"`
	//usage infomation
	DataFreeBytes        uint64   `protobuf:"varint,3,opt,name=DataFreeBytes,proto3" json:"DataFreeBytes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WorkerStatus) Reset()         { *m = WorkerStatus{} }
func (m *WorkerStatus) String() string { return proto.CompactTextString(m) }
func (*WorkerStatus) ProtoMessage()    {}
func (*WorkerStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{17}
}
func (m *WorkerStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkerStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkerStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkerStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkerStatus.Merge(m, src)
}
func (m *WorkerStatus) XXX_Size() int {
	return m.Size()
}
func (m *WorkerStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkerStatus.DiscardUnknown(m)
}

var xxx_messageInfo_WorkerStatus proto.InternalMessageInfo

func (m *WorkerStatus) GetProgress() map[uint64]WorkerStatus_ProgressType {
	if m != nil {
		return m.Progress
	}
	return nil
}

func (m *WorkerStatus) GetRaftContext() *RaftContext {
	if m != nil {
		return m.RaftContext
	}
	return nil
}

func (m *WorkerStatus) GetDataFreeBytes() uint64 {
	if m != nil {
		return m.DataFreeBytes
	}
	return 0
}

type ZeroHeartbeatRequest struct {
	StoreId uint64 `protobuf:"varint,1,opt,name=storeId,proto3" json:"storeId,omitempty"`
	//gid => workerstatus
	Workers              map[uint64]*WorkerStatus `protobuf:"bytes,2,rep,name=workers,proto3" json:"workers,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *ZeroHeartbeatRequest) Reset()         { *m = ZeroHeartbeatRequest{} }
func (m *ZeroHeartbeatRequest) String() string { return proto.CompactTextString(m) }
func (*ZeroHeartbeatRequest) ProtoMessage()    {}
func (*ZeroHeartbeatRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{18}
}
func (m *ZeroHeartbeatRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZeroHeartbeatRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZeroHeartbeatRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZeroHeartbeatRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZeroHeartbeatRequest.Merge(m, src)
}
func (m *ZeroHeartbeatRequest) XXX_Size() int {
	return m.Size()
}
func (m *ZeroHeartbeatRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ZeroHeartbeatRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ZeroHeartbeatRequest proto.InternalMessageInfo

func (m *ZeroHeartbeatRequest) GetStoreId() uint64 {
	if m != nil {
		return m.StoreId
	}
	return 0
}

func (m *ZeroHeartbeatRequest) GetWorkers() map[uint64]*WorkerStatus {
	if m != nil {
		return m.Workers
	}
	return nil
}

type ZeroHeartbeatResponse struct {
	ErrorMsg             string   `protobuf:"bytes,1,opt,name=errorMsg,proto3" json:"errorMsg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ZeroHeartbeatResponse) Reset()         { *m = ZeroHeartbeatResponse{} }
func (m *ZeroHeartbeatResponse) String() string { return proto.CompactTextString(m) }
func (*ZeroHeartbeatResponse) ProtoMessage()    {}
func (*ZeroHeartbeatResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{19}
}
func (m *ZeroHeartbeatResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZeroHeartbeatResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZeroHeartbeatResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZeroHeartbeatResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZeroHeartbeatResponse.Merge(m, src)
}
func (m *ZeroHeartbeatResponse) XXX_Size() int {
	return m.Size()
}
func (m *ZeroHeartbeatResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ZeroHeartbeatResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ZeroHeartbeatResponse proto.InternalMessageInfo

func (m *ZeroHeartbeatResponse) GetErrorMsg() string {
	if m != nil {
		return m.ErrorMsg
	}
	return ""
}

type ZeroRegistStoreRequest struct {
	Address              string   `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	StoreId              uint64   `protobuf:"varint,2,opt,name=storeId,proto3" json:"storeId,omitempty"`
	EmtpySlots           uint64   `protobuf:"varint,3,opt,name=emtpySlots,proto3" json:"emtpySlots,omitempty"`
	Name                 string   `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ZeroRegistStoreRequest) Reset()         { *m = ZeroRegistStoreRequest{} }
func (m *ZeroRegistStoreRequest) String() string { return proto.CompactTextString(m) }
func (*ZeroRegistStoreRequest) ProtoMessage()    {}
func (*ZeroRegistStoreRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{20}
}
func (m *ZeroRegistStoreRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZeroRegistStoreRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZeroRegistStoreRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZeroRegistStoreRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZeroRegistStoreRequest.Merge(m, src)
}
func (m *ZeroRegistStoreRequest) XXX_Size() int {
	return m.Size()
}
func (m *ZeroRegistStoreRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ZeroRegistStoreRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ZeroRegistStoreRequest proto.InternalMessageInfo

func (m *ZeroRegistStoreRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *ZeroRegistStoreRequest) GetStoreId() uint64 {
	if m != nil {
		return m.StoreId
	}
	return 0
}

func (m *ZeroRegistStoreRequest) GetEmtpySlots() uint64 {
	if m != nil {
		return m.EmtpySlots
	}
	return 0
}

func (m *ZeroRegistStoreRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type ZeroRegistStoreResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ZeroRegistStoreResponse) Reset()         { *m = ZeroRegistStoreResponse{} }
func (m *ZeroRegistStoreResponse) String() string { return proto.CompactTextString(m) }
func (*ZeroRegistStoreResponse) ProtoMessage()    {}
func (*ZeroRegistStoreResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{21}
}
func (m *ZeroRegistStoreResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZeroRegistStoreResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZeroRegistStoreResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZeroRegistStoreResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZeroRegistStoreResponse.Merge(m, src)
}
func (m *ZeroRegistStoreResponse) XXX_Size() int {
	return m.Size()
}
func (m *ZeroRegistStoreResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ZeroRegistStoreResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ZeroRegistStoreResponse proto.InternalMessageInfo

type ZeroWorkerInfo struct {
	WorkId               uint64   `protobuf:"varint,1,opt,name=workId,proto3" json:"workId,omitempty"`
	StoreId              uint64   `protobuf:"varint,2,opt,name=storeId,proto3" json:"storeId,omitempty"`
	Gid                  uint64   `protobuf:"varint,3,opt,name=gid,proto3" json:"gid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ZeroWorkerInfo) Reset()         { *m = ZeroWorkerInfo{} }
func (m *ZeroWorkerInfo) String() string { return proto.CompactTextString(m) }
func (*ZeroWorkerInfo) ProtoMessage()    {}
func (*ZeroWorkerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{22}
}
func (m *ZeroWorkerInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZeroWorkerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZeroWorkerInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZeroWorkerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZeroWorkerInfo.Merge(m, src)
}
func (m *ZeroWorkerInfo) XXX_Size() int {
	return m.Size()
}
func (m *ZeroWorkerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ZeroWorkerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ZeroWorkerInfo proto.InternalMessageInfo

func (m *ZeroWorkerInfo) GetWorkId() uint64 {
	if m != nil {
		return m.WorkId
	}
	return 0
}

func (m *ZeroWorkerInfo) GetStoreId() uint64 {
	if m != nil {
		return m.StoreId
	}
	return 0
}

func (m *ZeroWorkerInfo) GetGid() uint64 {
	if m != nil {
		return m.Gid
	}
	return 0
}

type ZeroStoreInfo struct {
	Address              string   `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	StoreId              uint64   `protobuf:"varint,2,opt,name=storeId,proto3" json:"storeId,omitempty"`
	Slots                uint64   `protobuf:"varint,3,opt,name=slots,proto3" json:"slots,omitempty"`
	Name                 string   `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ZeroStoreInfo) Reset()         { *m = ZeroStoreInfo{} }
func (m *ZeroStoreInfo) String() string { return proto.CompactTextString(m) }
func (*ZeroStoreInfo) ProtoMessage()    {}
func (*ZeroStoreInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{23}
}
func (m *ZeroStoreInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZeroStoreInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZeroStoreInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZeroStoreInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZeroStoreInfo.Merge(m, src)
}
func (m *ZeroStoreInfo) XXX_Size() int {
	return m.Size()
}
func (m *ZeroStoreInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ZeroStoreInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ZeroStoreInfo proto.InternalMessageInfo

func (m *ZeroStoreInfo) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *ZeroStoreInfo) GetStoreId() uint64 {
	if m != nil {
		return m.StoreId
	}
	return 0
}

func (m *ZeroStoreInfo) GetSlots() uint64 {
	if m != nil {
		return m.Slots
	}
	return 0
}

func (m *ZeroStoreInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type ZeroAddWorkerGroupRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ZeroAddWorkerGroupRequest) Reset()         { *m = ZeroAddWorkerGroupRequest{} }
func (m *ZeroAddWorkerGroupRequest) String() string { return proto.CompactTextString(m) }
func (*ZeroAddWorkerGroupRequest) ProtoMessage()    {}
func (*ZeroAddWorkerGroupRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{24}
}
func (m *ZeroAddWorkerGroupRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZeroAddWorkerGroupRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZeroAddWorkerGroupRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZeroAddWorkerGroupRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZeroAddWorkerGroupRequest.Merge(m, src)
}
func (m *ZeroAddWorkerGroupRequest) XXX_Size() int {
	return m.Size()
}
func (m *ZeroAddWorkerGroupRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ZeroAddWorkerGroupRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ZeroAddWorkerGroupRequest proto.InternalMessageInfo

type ZeroAddWorkerGroupResponse struct {
	Gid                  uint64   `protobuf:"varint,1,opt,name=gid,proto3" json:"gid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ZeroAddWorkerGroupResponse) Reset()         { *m = ZeroAddWorkerGroupResponse{} }
func (m *ZeroAddWorkerGroupResponse) String() string { return proto.CompactTextString(m) }
func (*ZeroAddWorkerGroupResponse) ProtoMessage()    {}
func (*ZeroAddWorkerGroupResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{25}
}
func (m *ZeroAddWorkerGroupResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZeroAddWorkerGroupResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZeroAddWorkerGroupResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZeroAddWorkerGroupResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZeroAddWorkerGroupResponse.Merge(m, src)
}
func (m *ZeroAddWorkerGroupResponse) XXX_Size() int {
	return m.Size()
}
func (m *ZeroAddWorkerGroupResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ZeroAddWorkerGroupResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ZeroAddWorkerGroupResponse proto.InternalMessageInfo

func (m *ZeroAddWorkerGroupResponse) GetGid() uint64 {
	if m != nil {
		return m.Gid
	}
	return 0
}

type ZeroQueryWorkerRequest struct {
	Gid                  uint64   `protobuf:"varint,1,opt,name=gid,proto3" json:"gid,omitempty"`
	Id                   uint64   `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	StoreId              uint64   `protobuf:"varint,3,opt,name=storeId,proto3" json:"storeId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ZeroQueryWorkerRequest) Reset()         { *m = ZeroQueryWorkerRequest{} }
func (m *ZeroQueryWorkerRequest) String() string { return proto.CompactTextString(m) }
func (*ZeroQueryWorkerRequest) ProtoMessage()    {}
func (*ZeroQueryWorkerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{26}
}
func (m *ZeroQueryWorkerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZeroQueryWorkerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZeroQueryWorkerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZeroQueryWorkerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZeroQueryWorkerRequest.Merge(m, src)
}
func (m *ZeroQueryWorkerRequest) XXX_Size() int {
	return m.Size()
}
func (m *ZeroQueryWorkerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ZeroQueryWorkerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ZeroQueryWorkerRequest proto.InternalMessageInfo

func (m *ZeroQueryWorkerRequest) GetGid() uint64 {
	if m != nil {
		return m.Gid
	}
	return 0
}

func (m *ZeroQueryWorkerRequest) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ZeroQueryWorkerRequest) GetStoreId() uint64 {
	if m != nil {
		return m.StoreId
	}
	return 0
}

type ZeroQueryWorkerResponse struct {
	Type                 TnxType  `protobuf:"varint,1,opt,name=type,proto3,enum=aspirapb.TnxType" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ZeroQueryWorkerResponse) Reset()         { *m = ZeroQueryWorkerResponse{} }
func (m *ZeroQueryWorkerResponse) String() string { return proto.CompactTextString(m) }
func (*ZeroQueryWorkerResponse) ProtoMessage()    {}
func (*ZeroQueryWorkerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{27}
}
func (m *ZeroQueryWorkerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZeroQueryWorkerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZeroQueryWorkerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZeroQueryWorkerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZeroQueryWorkerResponse.Merge(m, src)
}
func (m *ZeroQueryWorkerResponse) XXX_Size() int {
	return m.Size()
}
func (m *ZeroQueryWorkerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ZeroQueryWorkerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ZeroQueryWorkerResponse proto.InternalMessageInfo

func (m *ZeroQueryWorkerResponse) GetType() TnxType {
	if m != nil {
		return m.Type
	}
	return TnxType_prepare
}

type GroupStatus struct {
	Gid                  uint64           `protobuf:"varint,1,opt,name=gid,proto3" json:"gid,omitempty"`
	FreeBytes            uint64           `protobuf:"varint,2,opt,name=freeBytes,proto3" json:"freeBytes,omitempty"`
	Stores               []*ZeroStoreInfo `protobuf:"bytes,3,rep,name=stores,proto3" json:"stores,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *GroupStatus) Reset()         { *m = GroupStatus{} }
func (m *GroupStatus) String() string { return proto.CompactTextString(m) }
func (*GroupStatus) ProtoMessage()    {}
func (*GroupStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{28}
}
func (m *GroupStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GroupStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupStatus.Merge(m, src)
}
func (m *GroupStatus) XXX_Size() int {
	return m.Size()
}
func (m *GroupStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupStatus.DiscardUnknown(m)
}

var xxx_messageInfo_GroupStatus proto.InternalMessageInfo

func (m *GroupStatus) GetGid() uint64 {
	if m != nil {
		return m.Gid
	}
	return 0
}

func (m *GroupStatus) GetFreeBytes() uint64 {
	if m != nil {
		return m.FreeBytes
	}
	return 0
}

func (m *GroupStatus) GetStores() []*ZeroStoreInfo {
	if m != nil {
		return m.Stores
	}
	return nil
}

type ClusterStatusRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClusterStatusRequest) Reset()         { *m = ClusterStatusRequest{} }
func (m *ClusterStatusRequest) String() string { return proto.CompactTextString(m) }
func (*ClusterStatusRequest) ProtoMessage()    {}
func (*ClusterStatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{29}
}
func (m *ClusterStatusRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterStatusRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterStatusRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterStatusRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterStatusRequest.Merge(m, src)
}
func (m *ClusterStatusRequest) XXX_Size() int {
	return m.Size()
}
func (m *ClusterStatusRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterStatusRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterStatusRequest proto.InternalMessageInfo

type ClusterStatusResponse struct {
	Groups               []*GroupStatus `protobuf:"bytes,1,rep,name=groups,proto3" json:"groups,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ClusterStatusResponse) Reset()         { *m = ClusterStatusResponse{} }
func (m *ClusterStatusResponse) String() string { return proto.CompactTextString(m) }
func (*ClusterStatusResponse) ProtoMessage()    {}
func (*ClusterStatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_978c3dd237f791ac, []int{30}
}
func (m *ClusterStatusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterStatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterStatusResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterStatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterStatusResponse.Merge(m, src)
}
func (m *ClusterStatusResponse) XXX_Size() int {
	return m.Size()
}
func (m *ClusterStatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterStatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterStatusResponse proto.InternalMessageInfo

func (m *ClusterStatusResponse) GetGroups() []*GroupStatus {
	if m != nil {
		return m.Groups
	}
	return nil
}

func init() {
	proto.RegisterEnum("aspirapb.TnxType", TnxType_name, TnxType_value)
	proto.RegisterEnum("aspirapb.EntryMeta_Type", EntryMeta_Type_name, EntryMeta_Type_value)
	proto.RegisterEnum("aspirapb.AspiraProposal_Type", AspiraProposal_Type_name, AspiraProposal_Type_value)
	proto.RegisterEnum("aspirapb.WorkerStatus_ProgressType", WorkerStatus_ProgressType_name, WorkerStatus_ProgressType_value)
	proto.RegisterType((*Payload)(nil), "aspirapb.Payload")
	proto.RegisterType((*RaftContext)(nil), "aspirapb.RaftContext")
	proto.RegisterType((*MembershipState)(nil), "aspirapb.MembershipState")
	proto.RegisterMapType((map[uint64]string)(nil), "aspirapb.MembershipState.NodesEntry")
	proto.RegisterType((*Snapshot)(nil), "aspirapb.Snapshot")
	proto.RegisterType((*RaftBatch)(nil), "aspirapb.RaftBatch")
	proto.RegisterType((*EntryMeta)(nil), "aspirapb.EntryMeta")
	proto.RegisterType((*AspiraProposal)(nil), "aspirapb.AspiraProposal")
	proto.RegisterType((*BlobRaftMessageRequest)(nil), "aspirapb.BlobRaftMessageRequest")
	proto.RegisterType((*BlobRaftMessageResponse)(nil), "aspirapb.BlobRaftMessageResponse")
	proto.RegisterType((*AddWorkerRequest)(nil), "aspirapb.AddWorkerRequest")
	proto.RegisterType((*AddWorkerResponse)(nil), "aspirapb.AddWorkerResponse")
	proto.RegisterType((*PutStreamRequest)(nil), "aspirapb.PutStreamRequest")
	proto.RegisterType((*PutRequest)(nil), "aspirapb.PutRequest")
	proto.RegisterType((*PutResponse)(nil), "aspirapb.PutResponse")
	proto.RegisterType((*GetRequest)(nil), "aspirapb.GetRequest")
	proto.RegisterType((*ZeroAllocIDRequest)(nil), "aspirapb.ZeroAllocIDRequest")
	proto.RegisterType((*ZeroAllocIDResponse)(nil), "aspirapb.ZeroAllocIDResponse")
	proto.RegisterType((*WorkerStatus)(nil), "aspirapb.WorkerStatus")
	proto.RegisterMapType((map[uint64]WorkerStatus_ProgressType)(nil), "aspirapb.WorkerStatus.ProgressEntry")
	proto.RegisterType((*ZeroHeartbeatRequest)(nil), "aspirapb.ZeroHeartbeatRequest")
	proto.RegisterMapType((map[uint64]*WorkerStatus)(nil), "aspirapb.ZeroHeartbeatRequest.WorkersEntry")
	proto.RegisterType((*ZeroHeartbeatResponse)(nil), "aspirapb.ZeroHeartbeatResponse")
	proto.RegisterType((*ZeroRegistStoreRequest)(nil), "aspirapb.ZeroRegistStoreRequest")
	proto.RegisterType((*ZeroRegistStoreResponse)(nil), "aspirapb.ZeroRegistStoreResponse")
	proto.RegisterType((*ZeroWorkerInfo)(nil), "aspirapb.ZeroWorkerInfo")
	proto.RegisterType((*ZeroStoreInfo)(nil), "aspirapb.ZeroStoreInfo")
	proto.RegisterType((*ZeroAddWorkerGroupRequest)(nil), "aspirapb.ZeroAddWorkerGroupRequest")
	proto.RegisterType((*ZeroAddWorkerGroupResponse)(nil), "aspirapb.ZeroAddWorkerGroupResponse")
	proto.RegisterType((*ZeroQueryWorkerRequest)(nil), "aspirapb.ZeroQueryWorkerRequest")
	proto.RegisterType((*ZeroQueryWorkerResponse)(nil), "aspirapb.ZeroQueryWorkerResponse")
	proto.RegisterType((*GroupStatus)(nil), "aspirapb.GroupStatus")
	proto.RegisterType((*ClusterStatusRequest)(nil), "aspirapb.ClusterStatusRequest")
	proto.RegisterType((*ClusterStatusResponse)(nil), "aspirapb.ClusterStatusResponse")
}

func init() { proto.RegisterFile("aspirapb.proto", fileDescriptor_978c3dd237f791ac) }

var fileDescriptor_978c3dd237f791ac = []byte{
	// 1525 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0xed, 0x6e, 0x1b, 0x45,
	0x17, 0xf6, 0xfa, 0x33, 0x3e, 0x4e, 0xdc, 0xed, 0x34, 0x49, 0x5d, 0xb7, 0xcd, 0x9b, 0x77, 0xdb,
	0xf7, 0x55, 0xd4, 0xd2, 0xb4, 0xb8, 0x7c, 0xb4, 0x95, 0x40, 0xcd, 0x47, 0xdb, 0x84, 0x12, 0x6a,
	0x36, 0x86, 0x22, 0xa4, 0x0a, 0xc6, 0xde, 0x89, 0xb3, 0xd4, 0xde, 0x59, 0x66, 0xc7, 0x6d, 0xfd,
	0x8f, 0x7f, 0xbd, 0x05, 0xb8, 0x00, 0xee, 0x05, 0x09, 0x21, 0x71, 0x09, 0x28, 0x88, 0x5f, 0x5c,
	0x03, 0x12, 0x9a, 0xd9, 0xd9, 0xdd, 0x59, 0x7b, 0xed, 0x2a, 0x48, 0xfc, 0x9b, 0x99, 0x3d, 0x33,
	0xf3, 0x3c, 0xe7, 0x9c, 0x79, 0xce, 0xb1, 0xa1, 0x8e, 0x03, 0xdf, 0x65, 0xd8, 0xef, 0x6e, 0xfa,
	0x8c, 0x72, 0x8a, 0x16, 0xa2, 0xb9, 0x75, 0x19, 0x2a, 0x6d, 0x3c, 0x1e, 0x50, 0xec, 0x20, 0x04,
	0xc5, 0x5d, 0xcc, 0x71, 0xc3, 0x58, 0x37, 0x36, 0x16, 0x6d, 0x39, 0xb6, 0x76, 0xa0, 0x66, 0xe3,
	0x23, 0xbe, 0x43, 0x3d, 0x4e, 0x5e, 0x71, 0x54, 0x87, 0xbc, 0xeb, 0x48, 0x83, 0xa2, 0x9d, 0x77,
	0x1d, 0x64, 0x42, 0xa1, 0xef, 0x3a, 0x8d, 0xbc, 0x5c, 0x10, 0x43, 0x71, 0x08, 0x76, 0x1c, 0xd6,
	0x28, 0xac, 0x1b, 0x1b, 0x55, 0x5b, 0x8e, 0xad, 0xd7, 0x06, 0x9c, 0x39, 0x20, 0xc3, 0x2e, 0x61,
	0xc1, 0xb1, 0xeb, 0x1f, 0x72, 0xcc, 0x09, 0xba, 0x07, 0x25, 0x8f, 0x3a, 0x24, 0x68, 0x18, 0xeb,
	0x85, 0x8d, 0x5a, 0xeb, 0xea, 0x66, 0x8c, 0x70, 0xc2, 0x72, 0xf3, 0x13, 0x61, 0xf6, 0xc0, 0xe3,
	0x6c, 0x6c, 0x87, 0x5b, 0x9a, 0x77, 0x00, 0x92, 0x45, 0x81, 0xe1, 0x39, 0x19, 0x2b, 0x50, 0x62,
	0x88, 0x96, 0xa1, 0xf4, 0x02, 0x0f, 0x46, 0x44, 0xe2, 0xaa, 0xda, 0xe1, 0xe4, 0x5e, 0xfe, 0x8e,
	0x61, 0xfd, 0x60, 0xc0, 0xc2, 0xa1, 0x87, 0xfd, 0xe0, 0x98, 0x72, 0x74, 0x13, 0x2a, 0xbd, 0x90,
	0x97, 0xdc, 0x5c, 0x6b, 0xad, 0x24, 0x20, 0x34, 0xd2, 0x76, 0x64, 0x25, 0xce, 0x75, 0x3d, 0x87,
	0xbc, 0x52, 0x7c, 0xc3, 0x09, 0x3a, 0x0f, 0x15, 0x46, 0xb0, 0xf3, 0x15, 0x0f, 0x24, 0xe9, 0xa2,
	0x5d, 0x16, 0xd3, 0x4e, 0x20, 0x5c, 0xe1, 0x50, 0x8f, 0x34, 0x8a, 0xeb, 0xc6, 0xc6, 0x82, 0x2d,
	0xc7, 0xe8, 0x02, 0x2c, 0x04, 0xae, 0xd7, 0x23, 0xc2, 0xba, 0x24, 0xad, 0x2b, 0x72, 0xde, 0x09,
	0x2c, 0x17, 0xaa, 0xe2, 0xd6, 0x6d, 0xcc, 0x7b, 0xc7, 0xa7, 0xc7, 0x76, 0x1d, 0x2a, 0x7e, 0x18,
	0x47, 0x89, 0xae, 0xd6, 0x3a, 0x9b, 0x6c, 0x50, 0x01, 0xb6, 0x23, 0x0b, 0xeb, 0x4f, 0x03, 0xaa,
	0xd2, 0x79, 0x07, 0x84, 0x63, 0x81, 0xb3, 0x43, 0xd8, 0x50, 0x79, 0x50, 0x8e, 0x05, 0xd5, 0x7d,
	0x9d, 0xaa, 0x9c, 0xa0, 0xf7, 0xd4, 0xb6, 0xce, 0xd8, 0x27, 0x92, 0x6c, 0xbd, 0xd5, 0x48, 0xae,
	0x89, 0x4f, 0xdc, 0x14, 0xdf, 0xed, 0xc4, 0x34, 0xce, 0xac, 0x62, 0x92, 0x59, 0xc8, 0x82, 0x45,
	0x1c, 0x04, 0xb4, 0xe7, 0x62, 0x4e, 0x1e, 0x93, 0xb1, 0xf4, 0x46, 0xd5, 0x4e, 0xad, 0x59, 0xbb,
	0x50, 0x94, 0xfb, 0x2b, 0x50, 0x68, 0x8f, 0xb8, 0x99, 0x43, 0x26, 0x2c, 0x7e, 0x4c, 0xb0, 0x43,
	0xd8, 0x0e, 0x1d, 0x0e, 0x5d, 0x6e, 0x1a, 0xa8, 0x0e, 0xb0, 0x43, 0xbd, 0xa3, 0x9d, 0x63, 0xec,
	0xf5, 0x89, 0x99, 0x47, 0x67, 0x61, 0xa9, 0x3d, 0xe2, 0x4f, 0x5d, 0x7e, 0xfc, 0xe4, 0xe8, 0x28,
	0x20, 0xdc, 0x2c, 0x58, 0x7f, 0x18, 0x50, 0xdf, 0x92, 0x20, 0xdb, 0x8c, 0xfa, 0x34, 0xc0, 0x03,
	0xb4, 0x05, 0x8b, 0xd1, 0x58, 0x72, 0x31, 0x24, 0x97, 0xcb, 0x09, 0x97, 0xb4, 0x7d, 0x48, 0x28,
	0xb5, 0x25, 0x4a, 0xbb, 0x7c, 0x92, 0x76, 0xab, 0x50, 0xa6, 0xf2, 0xce, 0x28, 0x0f, 0xc2, 0xd9,
	0x14, 0xd3, 0xe2, 0x34, 0x53, 0x99, 0x2b, 0xc2, 0x43, 0xa5, 0xd0, 0x43, 0x62, 0x6c, 0x6d, 0x4e,
	0xb2, 0x9f, 0xe2, 0x66, 0x20, 0x80, 0xf2, 0x2e, 0x19, 0x10, 0x4e, 0xcc, 0xbc, 0xf5, 0x02, 0x56,
	0xb7, 0x07, 0xb4, 0x2b, 0xd2, 0xe3, 0x80, 0x04, 0x01, 0xee, 0x13, 0x9b, 0x7c, 0x3b, 0x22, 0x01,
	0xff, 0x97, 0xb3, 0xe9, 0x02, 0x9c, 0x9f, 0xba, 0x37, 0xf0, 0xa9, 0x17, 0x10, 0xeb, 0x47, 0x03,
	0xcc, 0x2d, 0xc7, 0x79, 0x4a, 0xd9, 0x73, 0xc2, 0x22, 0x34, 0x4a, 0x34, 0x8c, 0x44, 0x34, 0x42,
	0x59, 0xc9, 0xc7, 0xb2, 0xb2, 0x0e, 0xb5, 0x6f, 0xa8, 0xeb, 0xed, 0x0c, 0x46, 0x01, 0x27, 0x91,
	0x96, 0xe8, 0x4b, 0xe8, 0xff, 0x50, 0x77, 0x3d, 0x97, 0xbb, 0x78, 0x10, 0x19, 0x85, 0x5e, 0x9d,
	0x58, 0x45, 0xff, 0x83, 0x22, 0x17, 0x01, 0x2e, 0xc9, 0x00, 0x6b, 0x2c, 0x3a, 0xde, 0x2b, 0x19,
	0x54, 0xf9, 0xd9, 0x3a, 0x07, 0x67, 0x35, 0x98, 0x0a, 0xfc, 0x33, 0x30, 0xdb, 0x23, 0x7e, 0xc8,
	0x19, 0xc1, 0xc3, 0x08, 0x3b, 0xd2, 0xb0, 0xef, 0xe5, 0x42, 0xf4, 0x37, 0xde, 0xec, 0xac, 0xbd,
	0x5c, 0xec, 0xae, 0xed, 0x72, 0x18, 0x6a, 0xeb, 0x31, 0x40, 0x7b, 0xc4, 0x67, 0x3b, 0xe5, 0x54,
	0x31, 0x78, 0x1b, 0x6a, 0xf2, 0xb0, 0x10, 0x7a, 0xc6, 0x69, 0x26, 0x14, 0x68, 0xa2, 0xd4, 0xd4,
	0x75, 0xac, 0x5b, 0x00, 0x8f, 0xc8, 0x9c, 0xfb, 0xa7, 0x77, 0x5c, 0x03, 0xf4, 0x25, 0x61, 0x74,
	0x6b, 0x30, 0xa0, 0xbd, 0xfd, 0xdd, 0x68, 0xe7, 0x32, 0x94, 0x7a, 0x74, 0xe4, 0x85, 0xa9, 0x55,
	0xb2, 0xc3, 0x89, 0xf5, 0x01, 0x9c, 0x4b, 0xd9, 0x2a, 0x60, 0xcb, 0x50, 0x0a, 0x38, 0x66, 0x5c,
	0x5d, 0x14, 0x4e, 0xc4, 0x55, 0xc4, 0x8b, 0xaf, 0x22, 0x9e, 0x63, 0x9d, 0xe4, 0x61, 0x31, 0x0c,
	0x87, 0x28, 0x02, 0xa3, 0x00, 0xdd, 0x87, 0x05, 0x9f, 0xd1, 0x3e, 0x23, 0x41, 0x46, 0xc9, 0xd0,
	0x2d, 0x37, 0xdb, 0xca, 0x2c, 0x2c, 0x19, 0xf1, 0x2e, 0xf4, 0x3e, 0xd4, 0x58, 0x92, 0xeb, 0xca,
	0xa7, 0x33, 0x1e, 0x82, 0x6e, 0x89, 0xae, 0xc2, 0x92, 0x50, 0xac, 0x87, 0x8c, 0x90, 0xed, 0x31,
	0x27, 0x91, 0xcc, 0xa7, 0x17, 0x9b, 0x5f, 0xc3, 0x52, 0xea, 0xe6, 0x8c, 0xba, 0x74, 0x57, 0xaf,
	0x4b, 0xf5, 0xd6, 0x95, 0x37, 0x10, 0x90, 0xf9, 0xa9, 0x15, 0xaf, 0x27, 0x52, 0xb4, 0xe2, 0x4f,
	0xa8, 0x0a, 0xa5, 0x36, 0xa3, 0x5d, 0x62, 0xe6, 0xd0, 0x12, 0x54, 0x6d, 0xe2, 0x0f, 0xdc, 0x1e,
	0xe6, 0xc4, 0x34, 0xd0, 0x62, 0x52, 0xe5, 0xcc, 0x3c, 0xaa, 0x41, 0xe5, 0x33, 0xef, 0xb9, 0x47,
	0x5f, 0x7a, 0x66, 0x41, 0x08, 0x46, 0xa8, 0xa0, 0x66, 0xd1, 0xfa, 0xd9, 0x80, 0x65, 0x11, 0xa4,
	0x3d, 0x82, 0x19, 0xef, 0x12, 0x1c, 0x27, 0x43, 0x03, 0x2a, 0x01, 0xa7, 0x8c, 0xec, 0x47, 0x09,
	0x11, 0x4d, 0xd1, 0x03, 0xa8, 0xbc, 0x94, 0x58, 0x83, 0x46, 0x5e, 0x46, 0xe1, 0x7a, 0x42, 0x22,
	0xeb, 0x28, 0xc5, 0x4c, 0x05, 0x23, 0xda, 0xdb, 0xb4, 0xa3, 0xe8, 0xce, 0xf4, 0xd5, 0x5b, 0xba,
	0xaf, 0x6a, 0xad, 0xd5, 0x6c, 0x5f, 0xe9, 0xee, 0xb9, 0x0d, 0x2b, 0x13, 0x08, 0x54, 0xce, 0x35,
	0x61, 0x81, 0x30, 0x46, 0xd9, 0x41, 0xd0, 0x97, 0x37, 0x54, 0xed, 0x78, 0x6e, 0x7d, 0x67, 0xc0,
	0xaa, 0xd8, 0x65, 0x93, 0xbe, 0x1b, 0xf0, 0x43, 0xc1, 0x52, 0x73, 0x82, 0xe8, 0x5e, 0xc2, 0x84,
	0x13, 0xbb, 0xa2, 0xa9, 0xee, 0x9e, 0x7c, 0xda, 0x3d, 0x6b, 0x00, 0x64, 0xc8, 0xfd, 0xf1, 0xe1,
	0x80, 0xc6, 0xed, 0x80, 0xb6, 0x22, 0x64, 0xde, 0xc3, 0x43, 0xa2, 0xc4, 0x4a, 0x8e, 0x85, 0x7c,
	0x4e, 0x21, 0x50, 0x0a, 0xd4, 0x81, 0xba, 0xf8, 0x14, 0x32, 0xde, 0xf7, 0x8e, 0xa8, 0xa8, 0x31,
	0xc2, 0x87, 0x71, 0x60, 0xd4, 0x6c, 0x0e, 0x24, 0xf5, 0xb0, 0x0b, 0xf1, 0xc3, 0xb6, 0x86, 0xb0,
	0x24, 0x4e, 0x95, 0x57, 0xc9, 0x43, 0xff, 0x09, 0x53, 0xf1, 0x90, 0x35, 0x92, 0xe1, 0x24, 0x93,
	0xdf, 0x45, 0xb8, 0x20, 0x95, 0x20, 0xd2, 0xd7, 0x47, 0x8c, 0x8e, 0x7c, 0xe5, 0x64, 0x6b, 0x13,
	0x9a, 0x59, 0x1f, 0x67, 0xc9, 0x98, 0xd5, 0x09, 0xc3, 0xf5, 0xe9, 0x88, 0xb0, 0xf1, 0x69, 0xab,
	0x8a, 0x46, 0xa6, 0x90, 0x22, 0x63, 0xdd, 0x0f, 0x43, 0x90, 0x3a, 0x55, 0x41, 0x88, 0x0a, 0x88,
	0x31, 0xbf, 0x80, 0x78, 0x50, 0x93, 0xd0, 0x95, 0x5a, 0x4d, 0x83, 0xb9, 0x04, 0xd5, 0xa3, 0x58,
	0x40, 0x42, 0x4c, 0xc9, 0x02, 0xba, 0x09, 0x65, 0x89, 0x45, 0xb8, 0x53, 0xbc, 0xaa, 0xf3, 0xe9,
	0x57, 0x15, 0x87, 0xca, 0x56, 0x66, 0xd6, 0x2a, 0x2c, 0xab, 0x12, 0xa7, 0x1e, 0x82, 0xf2, 0xe7,
	0x43, 0x58, 0x99, 0x58, 0x57, 0x3c, 0x6e, 0x40, 0xb9, 0x2f, 0x00, 0x46, 0xea, 0xa9, 0x09, 0x9f,
	0x06, 0xdc, 0x56, 0x46, 0xd7, 0xee, 0x40, 0x45, 0x11, 0x14, 0xf2, 0xe1, 0x33, 0xe2, 0x63, 0x26,
	0x84, 0x06, 0xa0, 0xdc, 0x8b, 0x5a, 0xaf, 0x2a, 0x94, 0x70, 0x97, 0x32, 0x6e, 0x16, 0xc4, 0x90,
	0x11, 0xce, 0xc6, 0x66, 0xb1, 0xf5, 0x4b, 0x1e, 0x8a, 0x42, 0x4a, 0xd1, 0xbb, 0x50, 0x8d, 0xdf,
	0x22, 0x9a, 0xae, 0x5d, 0xcd, 0xe9, 0x25, 0x2b, 0x77, 0xcb, 0x40, 0x77, 0xc3, 0x5f, 0x1c, 0xaa,
	0x93, 0x40, 0xe7, 0xd2, 0x02, 0x2d, 0xbb, 0xe3, 0xcc, 0xad, 0x1b, 0x06, 0xfa, 0x02, 0xce, 0x4c,
	0x34, 0x22, 0x68, 0x3d, 0xb1, 0xcc, 0xee, 0x8d, 0x9a, 0xff, 0x9d, 0x63, 0xa1, 0x9e, 0x61, 0x4e,
	0x80, 0xfa, 0x48, 0xeb, 0x3e, 0xb2, 0xab, 0x46, 0x26, 0x2c, 0xf4, 0x21, 0xd4, 0xc3, 0x16, 0x22,
	0xfe, 0xdd, 0x71, 0x8a, 0xdd, 0xb7, 0x8c, 0xd6, 0x5f, 0x06, 0x94, 0x64, 0xfc, 0xd1, 0x43, 0xa8,
	0xc6, 0xef, 0x04, 0x35, 0xb5, 0x5e, 0x75, 0xa2, 0xc1, 0x6a, 0x5e, 0xcc, 0xfc, 0x16, 0x93, 0xd9,
	0x86, 0x6a, 0xdc, 0xd7, 0xe8, 0xe7, 0x4c, 0x36, 0x3b, 0xcd, 0x95, 0xd4, 0xb7, 0xe4, 0x84, 0x0d,
	0x03, 0xbd, 0x23, 0x7b, 0x52, 0xb4, 0x3c, 0x61, 0x31, 0x7f, 0x1f, 0x6a, 0x41, 0xe1, 0x11, 0x49,
	0xed, 0x4a, 0x3a, 0x90, 0x59, 0xfc, 0x5f, 0x17, 0xa1, 0x28, 0xde, 0x00, 0xda, 0x83, 0x8a, 0xea,
	0x26, 0xd0, 0xa5, 0xf4, 0xf3, 0x48, 0x37, 0x24, 0xcd, 0xcb, 0x33, 0xbe, 0xc6, 0x30, 0x3a, 0x50,
	0xd3, 0xd4, 0x56, 0xcf, 0x91, 0xec, 0x52, 0xa0, 0xe7, 0xc8, 0x2c, 0xa9, 0xce, 0xa1, 0xcf, 0xe1,
	0x4c, 0xe8, 0xbe, 0x24, 0xeb, 0xd7, 0xe6, 0x17, 0xc7, 0xe6, 0x7f, 0x66, 0x7e, 0xd7, 0x5c, 0xfd,
	0x0c, 0xea, 0x69, 0x79, 0x44, 0x57, 0x26, 0x08, 0x66, 0x29, 0x6b, 0xf3, 0xea, 0x7c, 0x23, 0xdd,
	0x19, 0x9a, 0xee, 0x4d, 0x3a, 0x63, 0x5a, 0x68, 0x27, 0x9d, 0x91, 0x21, 0x9a, 0x56, 0x0e, 0xd9,
	0xb0, 0x94, 0xd2, 0x21, 0xdd, 0x15, 0x59, 0xc2, 0xa5, 0xbb, 0x22, 0x53, 0xc0, 0xac, 0xdc, 0xb6,
	0xf9, 0xd3, 0xc9, 0x9a, 0xf1, 0xeb, 0xc9, 0x9a, 0xf1, 0xdb, 0xc9, 0x9a, 0xf1, 0xfd, 0xef, 0x6b,
	0xb9, 0x6e, 0x59, 0xfe, 0x9b, 0x71, 0xfb, 0xef, 0x00, 0x00, 0x00, 0xff, 0xff, 0x90, 0xcc, 0x3e,
	0x75, 0xdf, 0x10, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RaftClient is the client API for Raft service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RaftClient interface {
	Heartbeat(ctx context.Context, in *Payload, opts ...grpc.CallOption) (Raft_HeartbeatClient, error)
	RaftMessage(ctx context.Context, opts ...grpc.CallOption) (Raft_RaftMessageClient, error)
	BlobRaftMessage(ctx context.Context, in *BlobRaftMessageRequest, opts ...grpc.CallOption) (*BlobRaftMessageResponse, error)
	JoinCluster(ctx context.Context, in *RaftContext, opts ...grpc.CallOption) (*Payload, error)
	StreamSnapshot(ctx context.Context, in *RaftContext, opts ...grpc.CallOption) (Raft_StreamSnapshotClient, error)
}

type raftClient struct {
	cc *grpc.ClientConn
}

func NewRaftClient(cc *grpc.ClientConn) RaftClient {
	return &raftClient{cc}
}

func (c *raftClient) Heartbeat(ctx context.Context, in *Payload, opts ...grpc.CallOption) (Raft_HeartbeatClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Raft_serviceDesc.Streams[0], "/aspirapb.Raft/Heartbeat", opts...)
	if err != nil {
		return nil, err
	}
	x := &raftHeartbeatClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Raft_HeartbeatClient interface {
	Recv() (*Payload, error)
	grpc.ClientStream
}

type raftHeartbeatClient struct {
	grpc.ClientStream
}

func (x *raftHeartbeatClient) Recv() (*Payload, error) {
	m := new(Payload)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *raftClient) RaftMessage(ctx context.Context, opts ...grpc.CallOption) (Raft_RaftMessageClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Raft_serviceDesc.Streams[1], "/aspirapb.Raft/RaftMessage", opts...)
	if err != nil {
		return nil, err
	}
	x := &raftRaftMessageClient{stream}
	return x, nil
}

type Raft_RaftMessageClient interface {
	Send(*RaftBatch) error
	CloseAndRecv() (*Payload, error)
	grpc.ClientStream
}

type raftRaftMessageClient struct {
	grpc.ClientStream
}

func (x *raftRaftMessageClient) Send(m *RaftBatch) error {
	return x.ClientStream.SendMsg(m)
}

func (x *raftRaftMessageClient) CloseAndRecv() (*Payload, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Payload)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *raftClient) BlobRaftMessage(ctx context.Context, in *BlobRaftMessageRequest, opts ...grpc.CallOption) (*BlobRaftMessageResponse, error) {
	out := new(BlobRaftMessageResponse)
	err := c.cc.Invoke(ctx, "/aspirapb.Raft/BlobRaftMessage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftClient) JoinCluster(ctx context.Context, in *RaftContext, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/aspirapb.Raft/JoinCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftClient) StreamSnapshot(ctx context.Context, in *RaftContext, opts ...grpc.CallOption) (Raft_StreamSnapshotClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Raft_serviceDesc.Streams[2], "/aspirapb.Raft/StreamSnapshot", opts...)
	if err != nil {
		return nil, err
	}
	x := &raftStreamSnapshotClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Raft_StreamSnapshotClient interface {
	Recv() (*Payload, error)
	grpc.ClientStream
}

type raftStreamSnapshotClient struct {
	grpc.ClientStream
}

func (x *raftStreamSnapshotClient) Recv() (*Payload, error) {
	m := new(Payload)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// RaftServer is the server API for Raft service.
type RaftServer interface {
	Heartbeat(*Payload, Raft_HeartbeatServer) error
	RaftMessage(Raft_RaftMessageServer) error
	BlobRaftMessage(context.Context, *BlobRaftMessageRequest) (*BlobRaftMessageResponse, error)
	JoinCluster(context.Context, *RaftContext) (*Payload, error)
	StreamSnapshot(*RaftContext, Raft_StreamSnapshotServer) error
}

// UnimplementedRaftServer can be embedded to have forward compatible implementations.
type UnimplementedRaftServer struct {
}

func (*UnimplementedRaftServer) Heartbeat(req *Payload, srv Raft_HeartbeatServer) error {
	return status.Errorf(codes.Unimplemented, "method Heartbeat not implemented")
}
func (*UnimplementedRaftServer) RaftMessage(srv Raft_RaftMessageServer) error {
	return status.Errorf(codes.Unimplemented, "method RaftMessage not implemented")
}
func (*UnimplementedRaftServer) BlobRaftMessage(ctx context.Context, req *BlobRaftMessageRequest) (*BlobRaftMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BlobRaftMessage not implemented")
}
func (*UnimplementedRaftServer) JoinCluster(ctx context.Context, req *RaftContext) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JoinCluster not implemented")
}
func (*UnimplementedRaftServer) StreamSnapshot(req *RaftContext, srv Raft_StreamSnapshotServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamSnapshot not implemented")
}

func RegisterRaftServer(s *grpc.Server, srv RaftServer) {
	s.RegisterService(&_Raft_serviceDesc, srv)
}

func _Raft_Heartbeat_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Payload)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RaftServer).Heartbeat(m, &raftHeartbeatServer{stream})
}

type Raft_HeartbeatServer interface {
	Send(*Payload) error
	grpc.ServerStream
}

type raftHeartbeatServer struct {
	grpc.ServerStream
}

func (x *raftHeartbeatServer) Send(m *Payload) error {
	return x.ServerStream.SendMsg(m)
}

func _Raft_RaftMessage_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RaftServer).RaftMessage(&raftRaftMessageServer{stream})
}

type Raft_RaftMessageServer interface {
	SendAndClose(*Payload) error
	Recv() (*RaftBatch, error)
	grpc.ServerStream
}

type raftRaftMessageServer struct {
	grpc.ServerStream
}

func (x *raftRaftMessageServer) SendAndClose(m *Payload) error {
	return x.ServerStream.SendMsg(m)
}

func (x *raftRaftMessageServer) Recv() (*RaftBatch, error) {
	m := new(RaftBatch)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Raft_BlobRaftMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlobRaftMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftServer).BlobRaftMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/aspirapb.Raft/BlobRaftMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftServer).BlobRaftMessage(ctx, req.(*BlobRaftMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Raft_JoinCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RaftContext)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftServer).JoinCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/aspirapb.Raft/JoinCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftServer).JoinCluster(ctx, req.(*RaftContext))
	}
	return interceptor(ctx, in, info, handler)
}

func _Raft_StreamSnapshot_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RaftContext)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RaftServer).StreamSnapshot(m, &raftStreamSnapshotServer{stream})
}

type Raft_StreamSnapshotServer interface {
	Send(*Payload) error
	grpc.ServerStream
}

type raftStreamSnapshotServer struct {
	grpc.ServerStream
}

func (x *raftStreamSnapshotServer) Send(m *Payload) error {
	return x.ServerStream.SendMsg(m)
}

var _Raft_serviceDesc = grpc.ServiceDesc{
	ServiceName: "aspirapb.Raft",
	HandlerType: (*RaftServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "BlobRaftMessage",
			Handler:    _Raft_BlobRaftMessage_Handler,
		},
		{
			MethodName: "JoinCluster",
			Handler:    _Raft_JoinCluster_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Heartbeat",
			Handler:       _Raft_Heartbeat_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RaftMessage",
			Handler:       _Raft_RaftMessage_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamSnapshot",
			Handler:       _Raft_StreamSnapshot_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "aspirapb.proto",
}

// StoreClient is the client API for Store service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type StoreClient interface {
	AddWorker(ctx context.Context, in *AddWorkerRequest, opts ...grpc.CallOption) (*AddWorkerResponse, error)
	PutStream(ctx context.Context, opts ...grpc.CallOption) (Store_PutStreamClient, error)
	Put(ctx context.Context, in *PutRequest, opts ...grpc.CallOption) (*PutResponse, error)
	Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (Store_GetClient, error)
}

type storeClient struct {
	cc *grpc.ClientConn
}

func NewStoreClient(cc *grpc.ClientConn) StoreClient {
	return &storeClient{cc}
}

func (c *storeClient) AddWorker(ctx context.Context, in *AddWorkerRequest, opts ...grpc.CallOption) (*AddWorkerResponse, error) {
	out := new(AddWorkerResponse)
	err := c.cc.Invoke(ctx, "/aspirapb.Store/AddWorker", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storeClient) PutStream(ctx context.Context, opts ...grpc.CallOption) (Store_PutStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Store_serviceDesc.Streams[0], "/aspirapb.Store/PutStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &storePutStreamClient{stream}
	return x, nil
}

type Store_PutStreamClient interface {
	Send(*PutStreamRequest) error
	CloseAndRecv() (*PutResponse, error)
	grpc.ClientStream
}

type storePutStreamClient struct {
	grpc.ClientStream
}

func (x *storePutStreamClient) Send(m *PutStreamRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *storePutStreamClient) CloseAndRecv() (*PutResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(PutResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *storeClient) Put(ctx context.Context, in *PutRequest, opts ...grpc.CallOption) (*PutResponse, error) {
	out := new(PutResponse)
	err := c.cc.Invoke(ctx, "/aspirapb.Store/Put", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storeClient) Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (Store_GetClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Store_serviceDesc.Streams[1], "/aspirapb.Store/Get", opts...)
	if err != nil {
		return nil, err
	}
	x := &storeGetClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Store_GetClient interface {
	Recv() (*Payload, error)
	grpc.ClientStream
}

type storeGetClient struct {
	grpc.ClientStream
}

func (x *storeGetClient) Recv() (*Payload, error) {
	m := new(Payload)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// StoreServer is the server API for Store service.
type StoreServer interface {
	AddWorker(context.Context, *AddWorkerRequest) (*AddWorkerResponse, error)
	PutStream(Store_PutStreamServer) error
	Put(context.Context, *PutRequest) (*PutResponse, error)
	Get(*GetRequest, Store_GetServer) error
}

// UnimplementedStoreServer can be embedded to have forward compatible implementations.
type UnimplementedStoreServer struct {
}

func (*UnimplementedStoreServer) AddWorker(ctx context.Context, req *AddWorkerRequest) (*AddWorkerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddWorker not implemented")
}
func (*UnimplementedStoreServer) PutStream(srv Store_PutStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method PutStream not implemented")
}
func (*UnimplementedStoreServer) Put(ctx context.Context, req *PutRequest) (*PutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Put not implemented")
}
func (*UnimplementedStoreServer) Get(req *GetRequest, srv Store_GetServer) error {
	return status.Errorf(codes.Unimplemented, "method Get not implemented")
}

func RegisterStoreServer(s *grpc.Server, srv StoreServer) {
	s.RegisterService(&_Store_serviceDesc, srv)
}

func _Store_AddWorker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddWorkerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoreServer).AddWorker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/aspirapb.Store/AddWorker",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoreServer).AddWorker(ctx, req.(*AddWorkerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Store_PutStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(StoreServer).PutStream(&storePutStreamServer{stream})
}

type Store_PutStreamServer interface {
	SendAndClose(*PutResponse) error
	Recv() (*PutStreamRequest, error)
	grpc.ServerStream
}

type storePutStreamServer struct {
	grpc.ServerStream
}

func (x *storePutStreamServer) SendAndClose(m *PutResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *storePutStreamServer) Recv() (*PutStreamRequest, error) {
	m := new(PutStreamRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Store_Put_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoreServer).Put(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/aspirapb.Store/Put",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoreServer).Put(ctx, req.(*PutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Store_Get_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StoreServer).Get(m, &storeGetServer{stream})
}

type Store_GetServer interface {
	Send(*Payload) error
	grpc.ServerStream
}

type storeGetServer struct {
	grpc.ServerStream
}

func (x *storeGetServer) Send(m *Payload) error {
	return x.ServerStream.SendMsg(m)
}

var _Store_serviceDesc = grpc.ServiceDesc{
	ServiceName: "aspirapb.Store",
	HandlerType: (*StoreServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddWorker",
			Handler:    _Store_AddWorker_Handler,
		},
		{
			MethodName: "Put",
			Handler:    _Store_Put_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "PutStream",
			Handler:       _Store_PutStream_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Get",
			Handler:       _Store_Get_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "aspirapb.proto",
}

// ZeroClient is the client API for Zero service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ZeroClient interface {
	AllocID(ctx context.Context, in *ZeroAllocIDRequest, opts ...grpc.CallOption) (*ZeroAllocIDResponse, error)
	RegistStore(ctx context.Context, in *ZeroRegistStoreRequest, opts ...grpc.CallOption) (*ZeroRegistStoreResponse, error)
	StreamHeartbeat(ctx context.Context, opts ...grpc.CallOption) (Zero_StreamHeartbeatClient, error)
	AddWorkerGroup(ctx context.Context, in *ZeroAddWorkerGroupRequest, opts ...grpc.CallOption) (*ZeroAddWorkerGroupResponse, error)
	QueryWorker(ctx context.Context, in *ZeroQueryWorkerRequest, opts ...grpc.CallOption) (*ZeroQueryWorkerResponse, error)
	ClusterStatus(ctx context.Context, in *ClusterStatusRequest, opts ...grpc.CallOption) (*ClusterStatusResponse, error)
}

type zeroClient struct {
	cc *grpc.ClientConn
}

func NewZeroClient(cc *grpc.ClientConn) ZeroClient {
	return &zeroClient{cc}
}

func (c *zeroClient) AllocID(ctx context.Context, in *ZeroAllocIDRequest, opts ...grpc.CallOption) (*ZeroAllocIDResponse, error) {
	out := new(ZeroAllocIDResponse)
	err := c.cc.Invoke(ctx, "/aspirapb.Zero/AllocID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zeroClient) RegistStore(ctx context.Context, in *ZeroRegistStoreRequest, opts ...grpc.CallOption) (*ZeroRegistStoreResponse, error) {
	out := new(ZeroRegistStoreResponse)
	err := c.cc.Invoke(ctx, "/aspirapb.Zero/RegistStore", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zeroClient) StreamHeartbeat(ctx context.Context, opts ...grpc.CallOption) (Zero_StreamHeartbeatClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Zero_serviceDesc.Streams[0], "/aspirapb.Zero/StreamHeartbeat", opts...)
	if err != nil {
		return nil, err
	}
	x := &zeroStreamHeartbeatClient{stream}
	return x, nil
}

type Zero_StreamHeartbeatClient interface {
	Send(*ZeroHeartbeatRequest) error
	CloseAndRecv() (*ZeroHeartbeatResponse, error)
	grpc.ClientStream
}

type zeroStreamHeartbeatClient struct {
	grpc.ClientStream
}

func (x *zeroStreamHeartbeatClient) Send(m *ZeroHeartbeatRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *zeroStreamHeartbeatClient) CloseAndRecv() (*ZeroHeartbeatResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(ZeroHeartbeatResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *zeroClient) AddWorkerGroup(ctx context.Context, in *ZeroAddWorkerGroupRequest, opts ...grpc.CallOption) (*ZeroAddWorkerGroupResponse, error) {
	out := new(ZeroAddWorkerGroupResponse)
	err := c.cc.Invoke(ctx, "/aspirapb.Zero/AddWorkerGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zeroClient) QueryWorker(ctx context.Context, in *ZeroQueryWorkerRequest, opts ...grpc.CallOption) (*ZeroQueryWorkerResponse, error) {
	out := new(ZeroQueryWorkerResponse)
	err := c.cc.Invoke(ctx, "/aspirapb.Zero/QueryWorker", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zeroClient) ClusterStatus(ctx context.Context, in *ClusterStatusRequest, opts ...grpc.CallOption) (*ClusterStatusResponse, error) {
	out := new(ClusterStatusResponse)
	err := c.cc.Invoke(ctx, "/aspirapb.Zero/ClusterStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ZeroServer is the server API for Zero service.
type ZeroServer interface {
	AllocID(context.Context, *ZeroAllocIDRequest) (*ZeroAllocIDResponse, error)
	RegistStore(context.Context, *ZeroRegistStoreRequest) (*ZeroRegistStoreResponse, error)
	StreamHeartbeat(Zero_StreamHeartbeatServer) error
	AddWorkerGroup(context.Context, *ZeroAddWorkerGroupRequest) (*ZeroAddWorkerGroupResponse, error)
	QueryWorker(context.Context, *ZeroQueryWorkerRequest) (*ZeroQueryWorkerResponse, error)
	ClusterStatus(context.Context, *ClusterStatusRequest) (*ClusterStatusResponse, error)
}

// UnimplementedZeroServer can be embedded to have forward compatible implementations.
type UnimplementedZeroServer struct {
}

func (*UnimplementedZeroServer) AllocID(ctx context.Context, req *ZeroAllocIDRequest) (*ZeroAllocIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AllocID not implemented")
}
func (*UnimplementedZeroServer) RegistStore(ctx context.Context, req *ZeroRegistStoreRequest) (*ZeroRegistStoreResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegistStore not implemented")
}
func (*UnimplementedZeroServer) StreamHeartbeat(srv Zero_StreamHeartbeatServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamHeartbeat not implemented")
}
func (*UnimplementedZeroServer) AddWorkerGroup(ctx context.Context, req *ZeroAddWorkerGroupRequest) (*ZeroAddWorkerGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddWorkerGroup not implemented")
}
func (*UnimplementedZeroServer) QueryWorker(ctx context.Context, req *ZeroQueryWorkerRequest) (*ZeroQueryWorkerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryWorker not implemented")
}
func (*UnimplementedZeroServer) ClusterStatus(ctx context.Context, req *ClusterStatusRequest) (*ClusterStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClusterStatus not implemented")
}

func RegisterZeroServer(s *grpc.Server, srv ZeroServer) {
	s.RegisterService(&_Zero_serviceDesc, srv)
}

func _Zero_AllocID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ZeroAllocIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZeroServer).AllocID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/aspirapb.Zero/AllocID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZeroServer).AllocID(ctx, req.(*ZeroAllocIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Zero_RegistStore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ZeroRegistStoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZeroServer).RegistStore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/aspirapb.Zero/RegistStore",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZeroServer).RegistStore(ctx, req.(*ZeroRegistStoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Zero_StreamHeartbeat_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ZeroServer).StreamHeartbeat(&zeroStreamHeartbeatServer{stream})
}

type Zero_StreamHeartbeatServer interface {
	SendAndClose(*ZeroHeartbeatResponse) error
	Recv() (*ZeroHeartbeatRequest, error)
	grpc.ServerStream
}

type zeroStreamHeartbeatServer struct {
	grpc.ServerStream
}

func (x *zeroStreamHeartbeatServer) SendAndClose(m *ZeroHeartbeatResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *zeroStreamHeartbeatServer) Recv() (*ZeroHeartbeatRequest, error) {
	m := new(ZeroHeartbeatRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Zero_AddWorkerGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ZeroAddWorkerGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZeroServer).AddWorkerGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/aspirapb.Zero/AddWorkerGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZeroServer).AddWorkerGroup(ctx, req.(*ZeroAddWorkerGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Zero_QueryWorker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ZeroQueryWorkerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZeroServer).QueryWorker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/aspirapb.Zero/QueryWorker",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZeroServer).QueryWorker(ctx, req.(*ZeroQueryWorkerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Zero_ClusterStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClusterStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZeroServer).ClusterStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/aspirapb.Zero/ClusterStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZeroServer).ClusterStatus(ctx, req.(*ClusterStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Zero_serviceDesc = grpc.ServiceDesc{
	ServiceName: "aspirapb.Zero",
	HandlerType: (*ZeroServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AllocID",
			Handler:    _Zero_AllocID_Handler,
		},
		{
			MethodName: "RegistStore",
			Handler:    _Zero_RegistStore_Handler,
		},
		{
			MethodName: "AddWorkerGroup",
			Handler:    _Zero_AddWorkerGroup_Handler,
		},
		{
			MethodName: "QueryWorker",
			Handler:    _Zero_QueryWorker_Handler,
		},
		{
			MethodName: "ClusterStatus",
			Handler:    _Zero_ClusterStatus_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamHeartbeat",
			Handler:       _Zero_StreamHeartbeat_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "aspirapb.proto",
}

func (m *Payload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Payload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Payload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintAspirapb(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RaftContext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftContext) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftContext) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintAspirapb(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Gid != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.Gid))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MembershipState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MembershipState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MembershipState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Nodes) > 0 {
		for k := range m.Nodes {
			v := m.Nodes[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAspirapb(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i = encodeVarintAspirapb(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintAspirapb(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Snapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Snapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Snapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SinceTs != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.SinceTs))
		i--
		dAtA[i] = 0x28
	}
	if m.Done {
		i--
		if m.Done {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.ReadTs != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.ReadTs))
		i--
		dAtA[i] = 0x18
	}
	if m.Index != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	if m.Context != nil {
		{
			size, err := m.Context.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAspirapb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RaftBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftBatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftBatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAspirapb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Context != nil {
		{
			size, err := m.Context.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAspirapb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EntryMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EntryMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EntryMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AssociateKey) > 0 {
		i -= len(m.AssociateKey)
		copy(dAtA[i:], m.AssociateKey)
		i = encodeVarintAspirapb(dAtA, i, uint64(len(m.AssociateKey)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintAspirapb(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x22
	}
	if m.EntryType != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.EntryType))
		i--
		dAtA[i] = 0x18
	}
	if m.Index != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	if m.Term != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AspiraProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AspiraProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AspiraProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintAspirapb(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AssociateKey) > 0 {
		i -= len(m.AssociateKey)
		copy(dAtA[i:], m.AssociateKey)
		i = encodeVarintAspirapb(dAtA, i, uint64(len(m.AssociateKey)))
		i--
		dAtA[i] = 0x22
	}
	if m.Offset != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x18
	}
	if m.Key != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.Key))
		i--
		dAtA[i] = 0x10
	}
	if m.ProposalType != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.ProposalType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BlobRaftMessageRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlobRaftMessageRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlobRaftMessageRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAspirapb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Context != nil {
		{
			size, err := m.Context.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAspirapb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlobRaftMessageResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlobRaftMessageResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlobRaftMessageResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *AddWorkerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddWorkerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddWorkerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Type != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x28
	}
	if len(m.InitialCluster) > 0 {
		i -= len(m.InitialCluster)
		copy(dAtA[i:], m.InitialCluster)
		i = encodeVarintAspirapb(dAtA, i, uint64(len(m.InitialCluster)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.JoinCluster) > 0 {
		i -= len(m.JoinCluster)
		copy(dAtA[i:], m.JoinCluster)
		i = encodeVarintAspirapb(dAtA, i, uint64(len(m.JoinCluster)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Id != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x10
	}
	if m.Gid != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.Gid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AddWorkerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddWorkerResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddWorkerResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *PutStreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PutStreamRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PutStreamRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data != nil {
		{
			size := m.Data.Size()
			i -= size
			if _, err := m.Data.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *PutStreamRequest_Gid) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PutStreamRequest_Gid) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintAspirapb(dAtA, i, uint64(m.Gid))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *PutStreamRequest_Payload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PutStreamRequest_Payload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAspirapb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *PutRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PutRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PutRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAspirapb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Gid != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.Gid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PutResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PutResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PutResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Oid != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.Oid))
		i--
		dAtA[i] = 0x10
	}
	if m.Gid != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.Gid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Oid != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.Oid))
		i--
		dAtA[i] = 0x10
	}
	if m.Gid != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.Gid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ZeroAllocIDRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZeroAllocIDRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZeroAllocIDRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ZeroAllocIDResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZeroAllocIDResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZeroAllocIDResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.End != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x10
	}
	if m.Start != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WorkerStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkerStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkerStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DataFreeBytes != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.DataFreeBytes))
		i--
		dAtA[i] = 0x18
	}
	if m.RaftContext != nil {
		{
			size, err := m.RaftContext.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAspirapb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Progress) > 0 {
		for k := range m.Progress {
			v := m.Progress[k]
			baseI := i
			i = encodeVarintAspirapb(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintAspirapb(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintAspirapb(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ZeroHeartbeatRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZeroHeartbeatRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZeroHeartbeatRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Workers) > 0 {
		for k := range m.Workers {
			v := m.Workers[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintAspirapb(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintAspirapb(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintAspirapb(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.StoreId != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.StoreId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ZeroHeartbeatResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZeroHeartbeatResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZeroHeartbeatResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ErrorMsg) > 0 {
		i -= len(m.ErrorMsg)
		copy(dAtA[i:], m.ErrorMsg)
		i = encodeVarintAspirapb(dAtA, i, uint64(len(m.ErrorMsg)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ZeroRegistStoreRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZeroRegistStoreRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZeroRegistStoreRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAspirapb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if m.EmtpySlots != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.EmtpySlots))
		i--
		dAtA[i] = 0x18
	}
	if m.StoreId != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.StoreId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintAspirapb(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ZeroRegistStoreResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZeroRegistStoreResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZeroRegistStoreResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ZeroWorkerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZeroWorkerInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZeroWorkerInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Gid != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.Gid))
		i--
		dAtA[i] = 0x18
	}
	if m.StoreId != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.StoreId))
		i--
		dAtA[i] = 0x10
	}
	if m.WorkId != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.WorkId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ZeroStoreInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZeroStoreInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZeroStoreInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAspirapb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if m.Slots != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.Slots))
		i--
		dAtA[i] = 0x18
	}
	if m.StoreId != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.StoreId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintAspirapb(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ZeroAddWorkerGroupRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZeroAddWorkerGroupRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZeroAddWorkerGroupRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ZeroAddWorkerGroupResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZeroAddWorkerGroupResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZeroAddWorkerGroupResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Gid != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.Gid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ZeroQueryWorkerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZeroQueryWorkerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZeroQueryWorkerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.StoreId != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.StoreId))
		i--
		dAtA[i] = 0x18
	}
	if m.Id != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x10
	}
	if m.Gid != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.Gid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ZeroQueryWorkerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZeroQueryWorkerResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZeroQueryWorkerResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Type != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GroupStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GroupStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Stores) > 0 {
		for iNdEx := len(m.Stores) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Stores[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAspirapb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.FreeBytes != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.FreeBytes))
		i--
		dAtA[i] = 0x10
	}
	if m.Gid != 0 {
		i = encodeVarintAspirapb(dAtA, i, uint64(m.Gid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ClusterStatusRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterStatusRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterStatusRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ClusterStatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterStatusResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterStatusResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Groups) > 0 {
		for iNdEx := len(m.Groups) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Groups[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAspirapb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintAspirapb(dAtA []byte, offset int, v uint64) int {
	offset -= sovAspirapb(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Payload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovAspirapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftContext) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovAspirapb(uint64(m.Id))
	}
	if m.Gid != 0 {
		n += 1 + sovAspirapb(uint64(m.Gid))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovAspirapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MembershipState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for k, v := range m.Nodes {
			_ = k
			_ = v
			mapEntrySize := 1 + sovAspirapb(uint64(k)) + 1 + len(v) + sovAspirapb(uint64(len(v)))
			n += mapEntrySize + 1 + sovAspirapb(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Snapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovAspirapb(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovAspirapb(uint64(m.Index))
	}
	if m.ReadTs != 0 {
		n += 1 + sovAspirapb(uint64(m.ReadTs))
	}
	if m.Done {
		n += 2
	}
	if m.SinceTs != 0 {
		n += 1 + sovAspirapb(uint64(m.SinceTs))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovAspirapb(uint64(l))
	}
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovAspirapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EntryMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Term != 0 {
		n += 1 + sovAspirapb(uint64(m.Term))
	}
	if m.Index != 0 {
		n += 1 + sovAspirapb(uint64(m.Index))
	}
	if m.EntryType != 0 {
		n += 1 + sovAspirapb(uint64(m.EntryType))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovAspirapb(uint64(l))
	}
	l = len(m.AssociateKey)
	if l > 0 {
		n += 1 + l + sovAspirapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AspiraProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalType != 0 {
		n += 1 + sovAspirapb(uint64(m.ProposalType))
	}
	if m.Key != 0 {
		n += 1 + sovAspirapb(uint64(m.Key))
	}
	if m.Offset != 0 {
		n += 1 + sovAspirapb(uint64(m.Offset))
	}
	l = len(m.AssociateKey)
	if l > 0 {
		n += 1 + l + sovAspirapb(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovAspirapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlobRaftMessageRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovAspirapb(uint64(l))
	}
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovAspirapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlobRaftMessageResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddWorkerRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Gid != 0 {
		n += 1 + sovAspirapb(uint64(m.Gid))
	}
	if m.Id != 0 {
		n += 1 + sovAspirapb(uint64(m.Id))
	}
	l = len(m.JoinCluster)
	if l > 0 {
		n += 1 + l + sovAspirapb(uint64(l))
	}
	l = len(m.InitialCluster)
	if l > 0 {
		n += 1 + l + sovAspirapb(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovAspirapb(uint64(m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddWorkerResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PutStreamRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data != nil {
		n += m.Data.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PutStreamRequest_Gid) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovAspirapb(uint64(m.Gid))
	return n
}
func (m *PutStreamRequest_Payload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovAspirapb(uint64(l))
	}
	return n
}
func (m *PutRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Gid != 0 {
		n += 1 + sovAspirapb(uint64(m.Gid))
	}
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovAspirapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PutResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Gid != 0 {
		n += 1 + sovAspirapb(uint64(m.Gid))
	}
	if m.Oid != 0 {
		n += 1 + sovAspirapb(uint64(m.Oid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Gid != 0 {
		n += 1 + sovAspirapb(uint64(m.Gid))
	}
	if m.Oid != 0 {
		n += 1 + sovAspirapb(uint64(m.Oid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ZeroAllocIDRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Count != 0 {
		n += 1 + sovAspirapb(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ZeroAllocIDResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovAspirapb(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovAspirapb(uint64(m.End))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WorkerStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Progress) > 0 {
		for k, v := range m.Progress {
			_ = k
			_ = v
			mapEntrySize := 1 + sovAspirapb(uint64(k)) + 1 + sovAspirapb(uint64(v))
			n += mapEntrySize + 1 + sovAspirapb(uint64(mapEntrySize))
		}
	}
	if m.RaftContext != nil {
		l = m.RaftContext.Size()
		n += 1 + l + sovAspirapb(uint64(l))
	}
	if m.DataFreeBytes != 0 {
		n += 1 + sovAspirapb(uint64(m.DataFreeBytes))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ZeroHeartbeatRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StoreId != 0 {
		n += 1 + sovAspirapb(uint64(m.StoreId))
	}
	if len(m.Workers) > 0 {
		for k, v := range m.Workers {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovAspirapb(uint64(l))
			}
			mapEntrySize := 1 + sovAspirapb(uint64(k)) + l
			n += mapEntrySize + 1 + sovAspirapb(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ZeroHeartbeatResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ErrorMsg)
	if l > 0 {
		n += 1 + l + sovAspirapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ZeroRegistStoreRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovAspirapb(uint64(l))
	}
	if m.StoreId != 0 {
		n += 1 + sovAspirapb(uint64(m.StoreId))
	}
	if m.EmtpySlots != 0 {
		n += 1 + sovAspirapb(uint64(m.EmtpySlots))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAspirapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ZeroRegistStoreResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ZeroWorkerInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WorkId != 0 {
		n += 1 + sovAspirapb(uint64(m.WorkId))
	}
	if m.StoreId != 0 {
		n += 1 + sovAspirapb(uint64(m.StoreId))
	}
	if m.Gid != 0 {
		n += 1 + sovAspirapb(uint64(m.Gid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ZeroStoreInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovAspirapb(uint64(l))
	}
	if m.StoreId != 0 {
		n += 1 + sovAspirapb(uint64(m.StoreId))
	}
	if m.Slots != 0 {
		n += 1 + sovAspirapb(uint64(m.Slots))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAspirapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ZeroAddWorkerGroupRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ZeroAddWorkerGroupResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Gid != 0 {
		n += 1 + sovAspirapb(uint64(m.Gid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ZeroQueryWorkerRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Gid != 0 {
		n += 1 + sovAspirapb(uint64(m.Gid))
	}
	if m.Id != 0 {
		n += 1 + sovAspirapb(uint64(m.Id))
	}
	if m.StoreId != 0 {
		n += 1 + sovAspirapb(uint64(m.StoreId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ZeroQueryWorkerResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovAspirapb(uint64(m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GroupStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Gid != 0 {
		n += 1 + sovAspirapb(uint64(m.Gid))
	}
	if m.FreeBytes != 0 {
		n += 1 + sovAspirapb(uint64(m.FreeBytes))
	}
	if len(m.Stores) > 0 {
		for _, e := range m.Stores {
			l = e.Size()
			n += 1 + l + sovAspirapb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterStatusRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterStatusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Groups) > 0 {
		for _, e := range m.Groups {
			l = e.Size()
			n += 1 + l + sovAspirapb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovAspirapb(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAspirapb(x uint64) (n int) {
	return sovAspirapb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Payload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Payload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Payload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftContext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftContext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftContext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gid", wireType)
			}
			m.Gid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MembershipState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MembershipState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MembershipState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Nodes == nil {
				m.Nodes = make(map[uint64]string)
			}
			var mapkey uint64
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAspirapb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAspirapb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAspirapb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAspirapb
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAspirapb
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAspirapb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAspirapb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Nodes[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Snapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Snapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Snapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &RaftContext{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadTs", wireType)
			}
			m.ReadTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Done", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Done = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SinceTs", wireType)
			}
			m.SinceTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SinceTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &RaftContext{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &Payload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EntryMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntryMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntryMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryType", wireType)
			}
			m.EntryType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntryType |= EntryMeta_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssociateKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssociateKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AspiraProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AspiraProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AspiraProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalType", wireType)
			}
			m.ProposalType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposalType |= AspiraProposal_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssociateKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssociateKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlobRaftMessageRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlobRaftMessageRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlobRaftMessageRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &RaftContext{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &Payload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlobRaftMessageResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlobRaftMessageResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlobRaftMessageResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddWorkerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddWorkerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddWorkerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gid", wireType)
			}
			m.Gid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinCluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JoinCluster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialCluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitialCluster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= TnxType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddWorkerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddWorkerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddWorkerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PutStreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PutStreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PutStreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gid", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Data = &PutStreamRequest_Gid{v}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Payload{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &PutStreamRequest_Payload{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PutRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PutRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PutRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gid", wireType)
			}
			m.Gid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &Payload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PutResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PutResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PutResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gid", wireType)
			}
			m.Gid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oid", wireType)
			}
			m.Oid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Oid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gid", wireType)
			}
			m.Gid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oid", wireType)
			}
			m.Oid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Oid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZeroAllocIDRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZeroAllocIDRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZeroAllocIDRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZeroAllocIDResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZeroAllocIDResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZeroAllocIDResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkerStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkerStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkerStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Progress == nil {
				m.Progress = make(map[uint64]WorkerStatus_ProgressType)
			}
			var mapkey uint64
			var mapvalue WorkerStatus_ProgressType
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAspirapb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAspirapb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAspirapb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= WorkerStatus_ProgressType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAspirapb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAspirapb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Progress[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftContext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RaftContext == nil {
				m.RaftContext = &RaftContext{}
			}
			if err := m.RaftContext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataFreeBytes", wireType)
			}
			m.DataFreeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataFreeBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZeroHeartbeatRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZeroHeartbeatRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZeroHeartbeatRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			m.StoreId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Workers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Workers == nil {
				m.Workers = make(map[uint64]*WorkerStatus)
			}
			var mapkey uint64
			var mapvalue *WorkerStatus
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAspirapb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAspirapb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAspirapb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthAspirapb
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthAspirapb
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &WorkerStatus{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAspirapb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAspirapb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Workers[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZeroHeartbeatResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZeroHeartbeatResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZeroHeartbeatResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZeroRegistStoreRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZeroRegistStoreRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZeroRegistStoreRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			m.StoreId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmtpySlots", wireType)
			}
			m.EmtpySlots = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EmtpySlots |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZeroRegistStoreResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZeroRegistStoreResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZeroRegistStoreResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZeroWorkerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZeroWorkerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZeroWorkerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkId", wireType)
			}
			m.WorkId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			m.StoreId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gid", wireType)
			}
			m.Gid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZeroStoreInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZeroStoreInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZeroStoreInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			m.StoreId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slots", wireType)
			}
			m.Slots = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Slots |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZeroAddWorkerGroupRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZeroAddWorkerGroupRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZeroAddWorkerGroupRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZeroAddWorkerGroupResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZeroAddWorkerGroupResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZeroAddWorkerGroupResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gid", wireType)
			}
			m.Gid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZeroQueryWorkerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZeroQueryWorkerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZeroQueryWorkerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gid", wireType)
			}
			m.Gid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			m.StoreId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZeroQueryWorkerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZeroQueryWorkerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZeroQueryWorkerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= TnxType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gid", wireType)
			}
			m.Gid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreeBytes", wireType)
			}
			m.FreeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FreeBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stores", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stores = append(m.Stores, &ZeroStoreInfo{})
			if err := m.Stores[len(m.Stores)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterStatusRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterStatusRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterStatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterStatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterStatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterStatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAspirapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAspirapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Groups = append(m.Groups, &GroupStatus{})
			if err := m.Groups[len(m.Groups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAspirapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAspirapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAspirapb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAspirapb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAspirapb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAspirapb
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAspirapb
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAspirapb
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAspirapb        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAspirapb          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAspirapb = fmt.Errorf("proto: unexpected end of group")
)
